"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/http_ece";
exports.ids = ["vendor-chunks/http_ece"];
exports.modules = {

/***/ "(rsc)/./node_modules/http_ece/ece.js":
/*!**************************************!*\
  !*** ./node_modules/http_ece/ece.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\n * Encrypted content coding\n *\n * === Note about versions ===\n *\n * This code supports multiple versions of the draft.  This is selected using\n * the |version| parameter.\n *\n * aes128gcm: The most recent version, the salt, record size and key identifier\n *    are included in a header that is part of the encrypted content coding.\n *\n * aesgcm: The version that is widely deployed with WebPush (as of 2016-11).\n *    This version is selected by default, unless you specify a |padSize| of 1.\n */\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar AES_GCM = 'aes-128-gcm';\nvar PAD_SIZE = { 'aes128gcm': 1, 'aesgcm': 2 };\nvar TAG_LENGTH = 16;\nvar KEY_LENGTH = 16;\nvar NONCE_LENGTH = 12;\nvar SHA_256_LENGTH = 32;\nvar MODE_ENCRYPT = 'encrypt';\nvar MODE_DECRYPT = 'decrypt';\n\nvar keylog;\nif (process.env.ECE_KEYLOG === '1') {\n  keylog = function(m, k) {\n    console.warn(m + ' [' + k.length + ']: ' + k.toString('base64url'));\n    return k;\n  };\n} else {\n  keylog = function(m, k) { return k; };\n}\n\n/* Optionally base64 decode something. */\nfunction decode(b) {\n  if (typeof b === 'string') {\n    return Buffer.from(b, 'base64url');\n  }\n  return b;\n}\n\nfunction HMAC_hash(key, input) {\n  var hmac = crypto.createHmac('sha256', key);\n  hmac.update(input);\n  return hmac.digest();\n}\n\n/* HKDF as defined in RFC5869, using SHA-256 */\nfunction HKDF_extract(salt, ikm) {\n  keylog('salt', salt);\n  keylog('ikm', ikm);\n  return keylog('extract', HMAC_hash(salt, ikm));\n}\n\nfunction HKDF_expand(prk, info, l) {\n  keylog('prk', prk);\n  keylog('info', info);\n  var output = Buffer.alloc(0);\n  var T = Buffer.alloc(0);\n  info = Buffer.from(info, 'ascii');\n  var counter = 0;\n  var cbuf = Buffer.alloc(1);\n  while (output.length < l) {\n    cbuf.writeUIntBE(++counter, 0, 1);\n    T = HMAC_hash(prk, Buffer.concat([T, info, cbuf]));\n    output = Buffer.concat([output, T]);\n  }\n\n  return keylog('expand', output.slice(0, l));\n}\n\nfunction HKDF(salt, ikm, info, len) {\n  return HKDF_expand(HKDF_extract(salt, ikm), info, len);\n}\n\nfunction info(base, context) {\n  var result = Buffer.concat([\n    Buffer.from('Content-Encoding: ' + base + '\\0', 'ascii'),\n    context\n  ]);\n  keylog('info ' + base, result);\n  return result;\n}\n\nfunction lengthPrefix(buffer) {\n  var b = Buffer.concat([Buffer.alloc(2), buffer]);\n  b.writeUIntBE(buffer.length, 0, 2);\n  return b;\n}\n\nfunction extractDH(header, mode) {\n  var key = header.privateKey;\n  var senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = key.getPublicKey();\n    receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    senderPubKey = header.dh;\n    receiverPubKey = key.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  return {\n    secret: key.computeSecret(header.dh),\n    context: Buffer.concat([\n      Buffer.from(header.keylabel, 'ascii'),\n      Buffer.from([0]),\n      lengthPrefix(receiverPubKey), // user agent\n      lengthPrefix(senderPubKey)    // application server\n    ])\n  };\n}\n\nfunction extractSecretAndContext(header, mode) {\n  var result = { secret: null, context: Buffer.alloc(0) };\n  if (header.key) {\n    result.secret = header.key;\n    if (result.secret.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n  } else if (header.dh) { // receiver/decrypt\n    result = extractDH(header, mode);\n  } else if (typeof header.keyid !== undefined) {\n    result.secret = header.keymap[header.keyid];\n  }\n  if (!result.secret) {\n    throw new Error('Unable to determine key');\n  }\n  keylog('secret', result.secret);\n  keylog('context', result.context);\n  if (header.authSecret) {\n    result.secret = HKDF(header.authSecret, result.secret,\n                         info('auth', Buffer.alloc(0)), SHA_256_LENGTH);\n    keylog('authsecret', result.secret);\n  }\n  return result;\n}\n\nfunction webpushSecret(header, mode) {\n  if (!header.authSecret) {\n    throw new Error('No authentication secret for webpush');\n  }\n  keylog('authsecret', header.authSecret);\n\n  var remotePubKey, senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = header.privateKey.getPublicKey();\n    remotePubKey = receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    remotePubKey = senderPubKey = header.keyid;\n    receiverPubKey = header.privateKey.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  keylog('remote pubkey', remotePubKey);\n  keylog('sender pubkey', senderPubKey);\n  keylog('receiver pubkey', receiverPubKey);\n  return keylog('secret dh',\n                HKDF(header.authSecret,\n                     header.privateKey.computeSecret(remotePubKey),\n                     Buffer.concat([\n                       Buffer.from('WebPush: info\\0'),\n                       receiverPubKey,\n                       senderPubKey\n                     ]),\n                     SHA_256_LENGTH));\n}\n\nfunction extractSecret(header, mode, keyLookupCallback) {\n  if (keyLookupCallback) {\n    if (!isFunction(keyLookupCallback)) {\n      throw new Error('Callback is not a function')\n    }\n  }\n\n  if (header.key) {\n    if (header.key.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n    return keylog('secret key', header.key);\n  }\n\n  if (!header.privateKey) {\n    // Lookup based on keyid\n    if (!keyLookupCallback) {\n      var key = header.keymap && header.keymap[header.keyid];\n    } else {\n      var key = keyLookupCallback(header.keyid)\n    }\n    if (!key) {\n      throw new Error('No saved key (keyid: \"' + header.keyid + '\")');\n    }\n    return key;\n  }\n\n  return webpushSecret(header, mode);\n}\n\nfunction deriveKeyAndNonce(header, mode, lookupKeyCallback) {\n  if (!header.salt) {\n    throw new Error('must include a salt parameter for ' + header.version);\n  }\n  var keyInfo;\n  var nonceInfo;\n  var secret;\n  if (header.version === 'aesgcm') {\n    // old\n    var s = extractSecretAndContext(header, mode, lookupKeyCallback);\n    keyInfo = info('aesgcm', s.context);\n    nonceInfo = info('nonce', s.context);\n    secret = s.secret;\n  } else if (header.version === 'aes128gcm') {\n    // latest\n    keyInfo = Buffer.from('Content-Encoding: aes128gcm\\0');\n    nonceInfo = Buffer.from('Content-Encoding: nonce\\0');\n    secret = extractSecret(header, mode, lookupKeyCallback);\n  } else {\n    throw new Error('Unable to set context for mode ' + header.version);\n  }\n  var prk = HKDF_extract(header.salt, secret);\n  var result = {\n    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),\n    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)\n  };\n  keylog('key', result.key);\n  keylog('nonce base', result.nonce);\n  return result;\n}\n\n/* Parse command-line arguments. */\nfunction parseParams(params) {\n  var header = {};\n\n  header.version = params.version || 'aes128gcm';\n  header.rs = parseInt(params.rs, 10);\n  if (isNaN(header.rs)) {\n    header.rs = 4096;\n  }\n  var overhead = PAD_SIZE[header.version];\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  if (header.rs <= overhead) {\n    throw new Error('The rs parameter has to be greater than ' + overhead);\n  }\n\n  if (params.salt) {\n    header.salt = decode(params.salt);\n    if (header.salt.length !== KEY_LENGTH) {\n      throw new Error('The salt parameter must be ' + KEY_LENGTH + ' bytes');\n    }\n  }\n  header.keyid = params.keyid;\n  if (params.key) {\n    header.key = decode(params.key);\n  } else {\n    header.privateKey = params.privateKey;\n    if (!header.privateKey) {\n      header.keymap = params.keymap;\n    }\n    if (header.version !== 'aes128gcm') {\n      header.keylabel = params.keylabel || 'P-256';\n    }\n    if (params.dh) {\n      header.dh = decode(params.dh);\n    }\n  }\n  if (params.authSecret) {\n    header.authSecret = decode(params.authSecret);\n  }\n  return header;\n}\n\nfunction generateNonce(base, counter) {\n  var nonce = Buffer.from(base);\n  var m = nonce.readUIntBE(nonce.length - 6, 6);\n  var x = ((m ^ counter) & 0xffffff) +\n      ((((m / 0x1000000) ^ (counter / 0x1000000)) & 0xffffff) * 0x1000000);\n  nonce.writeUIntBE(x, nonce.length - 6, 6);\n  keylog('nonce' + counter, nonce);\n  return nonce;\n}\n\n/* Used when decrypting aes128gcm to populate the header values. Modifies the\n * header values in place and returns the size of the header. */\nfunction readHeader(buffer, header) {\n  var idsz = buffer.readUIntBE(20, 1);\n  header.salt = buffer.slice(0, KEY_LENGTH);\n  header.rs = buffer.readUIntBE(KEY_LENGTH, 4);\n  header.keyid = buffer.slice(21, 21 + idsz);\n  return 21 + idsz;\n}\n\nfunction unpadLegacy(data, version) {\n  var padSize = PAD_SIZE[version];\n  var pad = data.readUIntBE(0, padSize);\n  if (pad + padSize > data.length) {\n    throw new Error('padding exceeds block size');\n  }\n  keylog('padding', data.slice(0, padSize + pad));\n  var padCheck = Buffer.alloc(pad);\n  padCheck.fill(0);\n  if (padCheck.compare(data.slice(padSize, padSize + pad)) !== 0) {\n    throw new Error('invalid padding');\n  }\n  return data.slice(padSize + pad);\n}\n\nfunction unpad(data, last) {\n  var i = data.length - 1;\n  while(i >= 0) {\n    if (data[i]) {\n      if (last) {\n        if (data[i] !== 2) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      } else {\n        if (data[i] !== 1) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      }\n      return data.slice(0, i);\n    }\n    --i;\n  }\n  throw new Error('all zero plaintext');\n}\n\nfunction decryptRecord(key, counter, buffer, header, last) {\n  keylog('decrypt', buffer);\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createDecipheriv(AES_GCM, key.key, nonce);\n  gcm.setAuthTag(buffer.slice(buffer.length - TAG_LENGTH));\n  var data = gcm.update(buffer.slice(0, buffer.length - TAG_LENGTH));\n  data = Buffer.concat([data, gcm.final()]);\n  keylog('decrypted', data);\n  if (header.version !== 'aes128gcm') {\n    return unpadLegacy(data, header.version);\n  }\n  return unpad(data, last);\n}\n\n/**\n * Decrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.  Binary values are base64url encoded.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * If the version is aes128gcm, the keyid is extracted from the header and used\n * as the ECDH public key of the sender.  For version aesgcm ,\n * |params.dh| needs to be provided with the public key of the sender.\n *\n * The |params.privateKey| includes the private key of the receiver.\n */\nfunction decrypt(buffer, params, keyLookupCallback) {\n  var header = parseParams(params);\n  if (header.version === 'aes128gcm') {\n    var headerLength = readHeader(buffer, header);\n    buffer = buffer.slice(headerLength);\n  }\n  var key = deriveKeyAndNonce(header, MODE_DECRYPT, keyLookupCallback);\n  var start = 0;\n  var result = Buffer.alloc(0);\n\n  var chunkSize = header.rs;\n  if (header.version !== 'aes128gcm') {\n    chunkSize += TAG_LENGTH;\n  }\n\n  for (var i = 0; start < buffer.length; ++i) {\n    var end = start + chunkSize;\n    if (header.version !== 'aes128gcm' && end === buffer.length) {\n      throw new Error('Truncated payload');\n    }\n    end = Math.min(end, buffer.length);\n    if (end - start <= TAG_LENGTH) {\n      throw new Error('Invalid block: too small at ' + i);\n    }\n    var block = decryptRecord(key, i, buffer.slice(start, end),\n                              header, end >= buffer.length);\n    result = Buffer.concat([result, block]);\n    start = end;\n  }\n  return result;\n}\n\nfunction encryptRecord(key, counter, buffer, pad, header, last) {\n  keylog('encrypt', buffer);\n  pad = pad || 0;\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createCipheriv(AES_GCM, key.key, nonce);\n\n  var ciphertext = [];\n  var padSize = PAD_SIZE[header.version];\n  var padding = Buffer.alloc(pad + padSize);\n  padding.fill(0);\n\n  if (header.version !== 'aes128gcm') {\n    padding.writeUIntBE(pad, 0, padSize);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n    ciphertext.push(gcm.update(buffer));\n\n    if (!last && padding.length + buffer.length < header.rs) {\n      throw new Error('Unable to pad to record size');\n    }\n  } else {\n    ciphertext.push(gcm.update(buffer));\n    padding.writeUIntBE(last ? 2 : 1, 0, 1);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n  }\n\n  gcm.final();\n  var tag = gcm.getAuthTag();\n  if (tag.length !== TAG_LENGTH) {\n    throw new Error('invalid tag generated');\n  }\n  ciphertext.push(tag);\n  return keylog('encrypted', Buffer.concat(ciphertext));\n}\n\nfunction writeHeader(header) {\n  var ints = Buffer.alloc(5);\n  var keyid = Buffer.from(header.keyid || []);\n  if (keyid.length > 255) {\n    throw new Error('keyid is too large');\n  }\n  ints.writeUIntBE(header.rs, 0, 4);\n  ints.writeUIntBE(keyid.length, 4, 1);\n  return Buffer.concat([header.salt, ints, keyid]);\n}\n\n/**\n * Encrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter two might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * For Diffie-Hellman (WebPush), |params.dh| includes the public key of the\n * receiver.  |params.privateKey| is used to establish a shared secret.  Key\n * pairs can be created using |crypto.createECDH()|.\n */\nfunction encrypt(buffer, params, keyLookupCallback) {  \n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error('buffer argument must be a Buffer');\n  }\n  var header = parseParams(params);\n  if (!header.salt) {\n    header.salt = crypto.randomBytes(KEY_LENGTH);\n  }\n\n  var result;\n  if (header.version === 'aes128gcm') {\n    // Save the DH public key in the header unless keyid is set.\n    if (header.privateKey && !header.keyid) {\n      header.keyid = header.privateKey.getPublicKey();\n    }\n    result = writeHeader(header);\n  } else {\n    // No header on other versions\n    result = Buffer.alloc(0);\n  }\n\n  var key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);\n  var start = 0;\n  var padSize = PAD_SIZE[header.version];\n  var overhead = padSize;\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  var pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);\n\n  var counter = 0;\n  var last = false;\n  while (!last) {\n    // Pad so that at least one data byte is in a block.\n    var recordPad = Math.min(header.rs - overhead - 1, pad);\n    if (header.version !== 'aes128gcm') {\n      recordPad = Math.min((1 << (padSize * 8)) - 1, recordPad);\n    }\n    if (pad > 0 && recordPad === 0) {\n      ++recordPad; // Deal with perverse case of rs=overhead+1 with padding.\n    }\n    pad -= recordPad;\n\n    var end = start + header.rs - overhead - recordPad;\n    if (header.version !== 'aes128gcm') {\n      // The > here ensures that we write out a padding-only block at the end\n      // of a buffer.\n      last = end > buffer.length;\n    } else {\n      last = end >= buffer.length;\n    }\n    last = last && pad <= 0;\n    var block = encryptRecord(key, counter, buffer.slice(start, end),\n                              recordPad, header, last);\n    result = Buffer.concat([result, block]);\n\n    start = end;\n    ++counter;\n  }\n  return result;\n}\n\n\nfunction isFunction(object) {\n  return typeof(object) === 'function';\n }\n\nmodule.exports = {\n  decrypt: decrypt,\n  encrypt: encrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cF9lY2UvZWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHVqb2UtYWktY29hY2gvLi9ub2RlX21vZHVsZXMvaHR0cF9lY2UvZWNlLmpzPzJlYmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLypcbiAqIEVuY3J5cHRlZCBjb250ZW50IGNvZGluZ1xuICpcbiAqID09PSBOb3RlIGFib3V0IHZlcnNpb25zID09PVxuICpcbiAqIFRoaXMgY29kZSBzdXBwb3J0cyBtdWx0aXBsZSB2ZXJzaW9ucyBvZiB0aGUgZHJhZnQuICBUaGlzIGlzIHNlbGVjdGVkIHVzaW5nXG4gKiB0aGUgfHZlcnNpb258IHBhcmFtZXRlci5cbiAqXG4gKiBhZXMxMjhnY206IFRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uLCB0aGUgc2FsdCwgcmVjb3JkIHNpemUgYW5kIGtleSBpZGVudGlmaWVyXG4gKiAgICBhcmUgaW5jbHVkZWQgaW4gYSBoZWFkZXIgdGhhdCBpcyBwYXJ0IG9mIHRoZSBlbmNyeXB0ZWQgY29udGVudCBjb2RpbmcuXG4gKlxuICogYWVzZ2NtOiBUaGUgdmVyc2lvbiB0aGF0IGlzIHdpZGVseSBkZXBsb3llZCB3aXRoIFdlYlB1c2ggKGFzIG9mIDIwMTYtMTEpLlxuICogICAgVGhpcyB2ZXJzaW9uIGlzIHNlbGVjdGVkIGJ5IGRlZmF1bHQsIHVubGVzcyB5b3Ugc3BlY2lmeSBhIHxwYWRTaXplfCBvZiAxLlxuICovXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxudmFyIEFFU19HQ00gPSAnYWVzLTEyOC1nY20nO1xudmFyIFBBRF9TSVpFID0geyAnYWVzMTI4Z2NtJzogMSwgJ2Flc2djbSc6IDIgfTtcbnZhciBUQUdfTEVOR1RIID0gMTY7XG52YXIgS0VZX0xFTkdUSCA9IDE2O1xudmFyIE5PTkNFX0xFTkdUSCA9IDEyO1xudmFyIFNIQV8yNTZfTEVOR1RIID0gMzI7XG52YXIgTU9ERV9FTkNSWVBUID0gJ2VuY3J5cHQnO1xudmFyIE1PREVfREVDUllQVCA9ICdkZWNyeXB0JztcblxudmFyIGtleWxvZztcbmlmIChwcm9jZXNzLmVudi5FQ0VfS0VZTE9HID09PSAnMScpIHtcbiAga2V5bG9nID0gZnVuY3Rpb24obSwgaykge1xuICAgIGNvbnNvbGUud2FybihtICsgJyBbJyArIGsubGVuZ3RoICsgJ106ICcgKyBrLnRvU3RyaW5nKCdiYXNlNjR1cmwnKSk7XG4gICAgcmV0dXJuIGs7XG4gIH07XG59IGVsc2Uge1xuICBrZXlsb2cgPSBmdW5jdGlvbihtLCBrKSB7IHJldHVybiBrOyB9O1xufVxuXG4vKiBPcHRpb25hbGx5IGJhc2U2NCBkZWNvZGUgc29tZXRoaW5nLiAqL1xuZnVuY3Rpb24gZGVjb2RlKGIpIHtcbiAgaWYgKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShiLCAnYmFzZTY0dXJsJyk7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIEhNQUNfaGFzaChrZXksIGlucHV0KSB7XG4gIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIGtleSk7XG4gIGhtYWMudXBkYXRlKGlucHV0KTtcbiAgcmV0dXJuIGhtYWMuZGlnZXN0KCk7XG59XG5cbi8qIEhLREYgYXMgZGVmaW5lZCBpbiBSRkM1ODY5LCB1c2luZyBTSEEtMjU2ICovXG5mdW5jdGlvbiBIS0RGX2V4dHJhY3Qoc2FsdCwgaWttKSB7XG4gIGtleWxvZygnc2FsdCcsIHNhbHQpO1xuICBrZXlsb2coJ2lrbScsIGlrbSk7XG4gIHJldHVybiBrZXlsb2coJ2V4dHJhY3QnLCBITUFDX2hhc2goc2FsdCwgaWttKSk7XG59XG5cbmZ1bmN0aW9uIEhLREZfZXhwYW5kKHByaywgaW5mbywgbCkge1xuICBrZXlsb2coJ3ByaycsIHByayk7XG4gIGtleWxvZygnaW5mbycsIGluZm8pO1xuICB2YXIgb3V0cHV0ID0gQnVmZmVyLmFsbG9jKDApO1xuICB2YXIgVCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgaW5mbyA9IEJ1ZmZlci5mcm9tKGluZm8sICdhc2NpaScpO1xuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBjYnVmID0gQnVmZmVyLmFsbG9jKDEpO1xuICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IGwpIHtcbiAgICBjYnVmLndyaXRlVUludEJFKCsrY291bnRlciwgMCwgMSk7XG4gICAgVCA9IEhNQUNfaGFzaChwcmssIEJ1ZmZlci5jb25jYXQoW1QsIGluZm8sIGNidWZdKSk7XG4gICAgb3V0cHV0ID0gQnVmZmVyLmNvbmNhdChbb3V0cHV0LCBUXSk7XG4gIH1cblxuICByZXR1cm4ga2V5bG9nKCdleHBhbmQnLCBvdXRwdXQuc2xpY2UoMCwgbCkpO1xufVxuXG5mdW5jdGlvbiBIS0RGKHNhbHQsIGlrbSwgaW5mbywgbGVuKSB7XG4gIHJldHVybiBIS0RGX2V4cGFuZChIS0RGX2V4dHJhY3Qoc2FsdCwgaWttKSwgaW5mbywgbGVuKTtcbn1cblxuZnVuY3Rpb24gaW5mbyhiYXNlLCBjb250ZXh0KSB7XG4gIHZhciByZXN1bHQgPSBCdWZmZXIuY29uY2F0KFtcbiAgICBCdWZmZXIuZnJvbSgnQ29udGVudC1FbmNvZGluZzogJyArIGJhc2UgKyAnXFwwJywgJ2FzY2lpJyksXG4gICAgY29udGV4dFxuICBdKTtcbiAga2V5bG9nKCdpbmZvICcgKyBiYXNlLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBsZW5ndGhQcmVmaXgoYnVmZmVyKSB7XG4gIHZhciBiID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKDIpLCBidWZmZXJdKTtcbiAgYi53cml0ZVVJbnRCRShidWZmZXIubGVuZ3RoLCAwLCAyKTtcbiAgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RESChoZWFkZXIsIG1vZGUpIHtcbiAgdmFyIGtleSA9IGhlYWRlci5wcml2YXRlS2V5O1xuICB2YXIgc2VuZGVyUHViS2V5LCByZWNlaXZlclB1YktleTtcbiAgaWYgKG1vZGUgPT09IE1PREVfRU5DUllQVCkge1xuICAgIHNlbmRlclB1YktleSA9IGtleS5nZXRQdWJsaWNLZXkoKTtcbiAgICByZWNlaXZlclB1YktleSA9IGhlYWRlci5kaDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBNT0RFX0RFQ1JZUFQpIHtcbiAgICBzZW5kZXJQdWJLZXkgPSBoZWFkZXIuZGg7XG4gICAgcmVjZWl2ZXJQdWJLZXkgPSBrZXkuZ2V0UHVibGljS2V5KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgb25seSAnICsgTU9ERV9FTkNSWVBUICtcbiAgICAgICAgICAgICAgICAgICAgJyBhbmQgJyArIE1PREVfREVDUllQVCArICcgc3VwcG9ydGVkJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzZWNyZXQ6IGtleS5jb21wdXRlU2VjcmV0KGhlYWRlci5kaCksXG4gICAgY29udGV4dDogQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbShoZWFkZXIua2V5bGFiZWwsICdhc2NpaScpLFxuICAgICAgQnVmZmVyLmZyb20oWzBdKSxcbiAgICAgIGxlbmd0aFByZWZpeChyZWNlaXZlclB1YktleSksIC8vIHVzZXIgYWdlbnRcbiAgICAgIGxlbmd0aFByZWZpeChzZW5kZXJQdWJLZXkpICAgIC8vIGFwcGxpY2F0aW9uIHNlcnZlclxuICAgIF0pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RTZWNyZXRBbmRDb250ZXh0KGhlYWRlciwgbW9kZSkge1xuICB2YXIgcmVzdWx0ID0geyBzZWNyZXQ6IG51bGwsIGNvbnRleHQ6IEJ1ZmZlci5hbGxvYygwKSB9O1xuICBpZiAoaGVhZGVyLmtleSkge1xuICAgIHJlc3VsdC5zZWNyZXQgPSBoZWFkZXIua2V5O1xuICAgIGlmIChyZXN1bHQuc2VjcmV0Lmxlbmd0aCAhPT0gS0VZX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBleHBsaWNpdCBrZXkgbXVzdCBiZSAnICsgS0VZX0xFTkdUSCArICcgYnl0ZXMnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZGVyLmRoKSB7IC8vIHJlY2VpdmVyL2RlY3J5cHRcbiAgICByZXN1bHQgPSBleHRyYWN0REgoaGVhZGVyLCBtb2RlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaGVhZGVyLmtleWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXN1bHQuc2VjcmV0ID0gaGVhZGVyLmtleW1hcFtoZWFkZXIua2V5aWRdO1xuICB9XG4gIGlmICghcmVzdWx0LnNlY3JldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRldGVybWluZSBrZXknKTtcbiAgfVxuICBrZXlsb2coJ3NlY3JldCcsIHJlc3VsdC5zZWNyZXQpO1xuICBrZXlsb2coJ2NvbnRleHQnLCByZXN1bHQuY29udGV4dCk7XG4gIGlmIChoZWFkZXIuYXV0aFNlY3JldCkge1xuICAgIHJlc3VsdC5zZWNyZXQgPSBIS0RGKGhlYWRlci5hdXRoU2VjcmV0LCByZXN1bHQuc2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8oJ2F1dGgnLCBCdWZmZXIuYWxsb2MoMCkpLCBTSEFfMjU2X0xFTkdUSCk7XG4gICAga2V5bG9nKCdhdXRoc2VjcmV0JywgcmVzdWx0LnNlY3JldCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd2VicHVzaFNlY3JldChoZWFkZXIsIG1vZGUpIHtcbiAgaWYgKCFoZWFkZXIuYXV0aFNlY3JldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gYXV0aGVudGljYXRpb24gc2VjcmV0IGZvciB3ZWJwdXNoJyk7XG4gIH1cbiAga2V5bG9nKCdhdXRoc2VjcmV0JywgaGVhZGVyLmF1dGhTZWNyZXQpO1xuXG4gIHZhciByZW1vdGVQdWJLZXksIHNlbmRlclB1YktleSwgcmVjZWl2ZXJQdWJLZXk7XG4gIGlmIChtb2RlID09PSBNT0RFX0VOQ1JZUFQpIHtcbiAgICBzZW5kZXJQdWJLZXkgPSBoZWFkZXIucHJpdmF0ZUtleS5nZXRQdWJsaWNLZXkoKTtcbiAgICByZW1vdGVQdWJLZXkgPSByZWNlaXZlclB1YktleSA9IGhlYWRlci5kaDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBNT0RFX0RFQ1JZUFQpIHtcbiAgICByZW1vdGVQdWJLZXkgPSBzZW5kZXJQdWJLZXkgPSBoZWFkZXIua2V5aWQ7XG4gICAgcmVjZWl2ZXJQdWJLZXkgPSBoZWFkZXIucHJpdmF0ZUtleS5nZXRQdWJsaWNLZXkoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZSBvbmx5ICcgKyBNT0RFX0VOQ1JZUFQgK1xuICAgICAgICAgICAgICAgICAgICAnIGFuZCAnICsgTU9ERV9ERUNSWVBUICsgJyBzdXBwb3J0ZWQnKTtcbiAgfVxuICBrZXlsb2coJ3JlbW90ZSBwdWJrZXknLCByZW1vdGVQdWJLZXkpO1xuICBrZXlsb2coJ3NlbmRlciBwdWJrZXknLCBzZW5kZXJQdWJLZXkpO1xuICBrZXlsb2coJ3JlY2VpdmVyIHB1YmtleScsIHJlY2VpdmVyUHViS2V5KTtcbiAgcmV0dXJuIGtleWxvZygnc2VjcmV0IGRoJyxcbiAgICAgICAgICAgICAgICBIS0RGKGhlYWRlci5hdXRoU2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLnByaXZhdGVLZXkuY29tcHV0ZVNlY3JldChyZW1vdGVQdWJLZXkpLFxuICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKCdXZWJQdXNoOiBpbmZvXFwwJyksXG4gICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyUHViS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXJQdWJLZXlcbiAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgU0hBXzI1Nl9MRU5HVEgpKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFNlY3JldChoZWFkZXIsIG1vZGUsIGtleUxvb2t1cENhbGxiYWNrKSB7XG4gIGlmIChrZXlMb29rdXBDYWxsYmFjaykge1xuICAgIGlmICghaXNGdW5jdGlvbihrZXlMb29rdXBDYWxsYmFjaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24nKVxuICAgIH1cbiAgfVxuXG4gIGlmIChoZWFkZXIua2V5KSB7XG4gICAgaWYgKGhlYWRlci5rZXkubGVuZ3RoICE9PSBLRVlfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGV4cGxpY2l0IGtleSBtdXN0IGJlICcgKyBLRVlfTEVOR1RIICsgJyBieXRlcycpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5bG9nKCdzZWNyZXQga2V5JywgaGVhZGVyLmtleSk7XG4gIH1cblxuICBpZiAoIWhlYWRlci5wcml2YXRlS2V5KSB7XG4gICAgLy8gTG9va3VwIGJhc2VkIG9uIGtleWlkXG4gICAgaWYgKCFrZXlMb29rdXBDYWxsYmFjaykge1xuICAgICAgdmFyIGtleSA9IGhlYWRlci5rZXltYXAgJiYgaGVhZGVyLmtleW1hcFtoZWFkZXIua2V5aWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5ID0ga2V5TG9va3VwQ2FsbGJhY2soaGVhZGVyLmtleWlkKVxuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzYXZlZCBrZXkgKGtleWlkOiBcIicgKyBoZWFkZXIua2V5aWQgKyAnXCIpJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICByZXR1cm4gd2VicHVzaFNlY3JldChoZWFkZXIsIG1vZGUpO1xufVxuXG5mdW5jdGlvbiBkZXJpdmVLZXlBbmROb25jZShoZWFkZXIsIG1vZGUsIGxvb2t1cEtleUNhbGxiYWNrKSB7XG4gIGlmICghaGVhZGVyLnNhbHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgaW5jbHVkZSBhIHNhbHQgcGFyYW1ldGVyIGZvciAnICsgaGVhZGVyLnZlcnNpb24pO1xuICB9XG4gIHZhciBrZXlJbmZvO1xuICB2YXIgbm9uY2VJbmZvO1xuICB2YXIgc2VjcmV0O1xuICBpZiAoaGVhZGVyLnZlcnNpb24gPT09ICdhZXNnY20nKSB7XG4gICAgLy8gb2xkXG4gICAgdmFyIHMgPSBleHRyYWN0U2VjcmV0QW5kQ29udGV4dChoZWFkZXIsIG1vZGUsIGxvb2t1cEtleUNhbGxiYWNrKTtcbiAgICBrZXlJbmZvID0gaW5mbygnYWVzZ2NtJywgcy5jb250ZXh0KTtcbiAgICBub25jZUluZm8gPSBpbmZvKCdub25jZScsIHMuY29udGV4dCk7XG4gICAgc2VjcmV0ID0gcy5zZWNyZXQ7XG4gIH0gZWxzZSBpZiAoaGVhZGVyLnZlcnNpb24gPT09ICdhZXMxMjhnY20nKSB7XG4gICAgLy8gbGF0ZXN0XG4gICAga2V5SW5mbyA9IEJ1ZmZlci5mcm9tKCdDb250ZW50LUVuY29kaW5nOiBhZXMxMjhnY21cXDAnKTtcbiAgICBub25jZUluZm8gPSBCdWZmZXIuZnJvbSgnQ29udGVudC1FbmNvZGluZzogbm9uY2VcXDAnKTtcbiAgICBzZWNyZXQgPSBleHRyYWN0U2VjcmV0KGhlYWRlciwgbW9kZSwgbG9va3VwS2V5Q2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNldCBjb250ZXh0IGZvciBtb2RlICcgKyBoZWFkZXIudmVyc2lvbik7XG4gIH1cbiAgdmFyIHByayA9IEhLREZfZXh0cmFjdChoZWFkZXIuc2FsdCwgc2VjcmV0KTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBrZXk6IEhLREZfZXhwYW5kKHByaywga2V5SW5mbywgS0VZX0xFTkdUSCksXG4gICAgbm9uY2U6IEhLREZfZXhwYW5kKHByaywgbm9uY2VJbmZvLCBOT05DRV9MRU5HVEgpXG4gIH07XG4gIGtleWxvZygna2V5JywgcmVzdWx0LmtleSk7XG4gIGtleWxvZygnbm9uY2UgYmFzZScsIHJlc3VsdC5ub25jZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qIFBhcnNlIGNvbW1hbmQtbGluZSBhcmd1bWVudHMuICovXG5mdW5jdGlvbiBwYXJzZVBhcmFtcyhwYXJhbXMpIHtcbiAgdmFyIGhlYWRlciA9IHt9O1xuXG4gIGhlYWRlci52ZXJzaW9uID0gcGFyYW1zLnZlcnNpb24gfHwgJ2FlczEyOGdjbSc7XG4gIGhlYWRlci5ycyA9IHBhcnNlSW50KHBhcmFtcy5ycywgMTApO1xuICBpZiAoaXNOYU4oaGVhZGVyLnJzKSkge1xuICAgIGhlYWRlci5ycyA9IDQwOTY7XG4gIH1cbiAgdmFyIG92ZXJoZWFkID0gUEFEX1NJWkVbaGVhZGVyLnZlcnNpb25dO1xuICBpZiAoaGVhZGVyLnZlcnNpb24gPT09ICdhZXMxMjhnY20nKSB7XG4gICAgb3ZlcmhlYWQgKz0gVEFHX0xFTkdUSDtcbiAgfVxuICBpZiAoaGVhZGVyLnJzIDw9IG92ZXJoZWFkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcnMgcGFyYW1ldGVyIGhhcyB0byBiZSBncmVhdGVyIHRoYW4gJyArIG92ZXJoZWFkKTtcbiAgfVxuXG4gIGlmIChwYXJhbXMuc2FsdCkge1xuICAgIGhlYWRlci5zYWx0ID0gZGVjb2RlKHBhcmFtcy5zYWx0KTtcbiAgICBpZiAoaGVhZGVyLnNhbHQubGVuZ3RoICE9PSBLRVlfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzYWx0IHBhcmFtZXRlciBtdXN0IGJlICcgKyBLRVlfTEVOR1RIICsgJyBieXRlcycpO1xuICAgIH1cbiAgfVxuICBoZWFkZXIua2V5aWQgPSBwYXJhbXMua2V5aWQ7XG4gIGlmIChwYXJhbXMua2V5KSB7XG4gICAgaGVhZGVyLmtleSA9IGRlY29kZShwYXJhbXMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIucHJpdmF0ZUtleSA9IHBhcmFtcy5wcml2YXRlS2V5O1xuICAgIGlmICghaGVhZGVyLnByaXZhdGVLZXkpIHtcbiAgICAgIGhlYWRlci5rZXltYXAgPSBwYXJhbXMua2V5bWFwO1xuICAgIH1cbiAgICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgICBoZWFkZXIua2V5bGFiZWwgPSBwYXJhbXMua2V5bGFiZWwgfHwgJ1AtMjU2JztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5kaCkge1xuICAgICAgaGVhZGVyLmRoID0gZGVjb2RlKHBhcmFtcy5kaCk7XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMuYXV0aFNlY3JldCkge1xuICAgIGhlYWRlci5hdXRoU2VjcmV0ID0gZGVjb2RlKHBhcmFtcy5hdXRoU2VjcmV0KTtcbiAgfVxuICByZXR1cm4gaGVhZGVyO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU5vbmNlKGJhc2UsIGNvdW50ZXIpIHtcbiAgdmFyIG5vbmNlID0gQnVmZmVyLmZyb20oYmFzZSk7XG4gIHZhciBtID0gbm9uY2UucmVhZFVJbnRCRShub25jZS5sZW5ndGggLSA2LCA2KTtcbiAgdmFyIHggPSAoKG0gXiBjb3VudGVyKSAmIDB4ZmZmZmZmKSArXG4gICAgICAoKCgobSAvIDB4MTAwMDAwMCkgXiAoY291bnRlciAvIDB4MTAwMDAwMCkpICYgMHhmZmZmZmYpICogMHgxMDAwMDAwKTtcbiAgbm9uY2Uud3JpdGVVSW50QkUoeCwgbm9uY2UubGVuZ3RoIC0gNiwgNik7XG4gIGtleWxvZygnbm9uY2UnICsgY291bnRlciwgbm9uY2UpO1xuICByZXR1cm4gbm9uY2U7XG59XG5cbi8qIFVzZWQgd2hlbiBkZWNyeXB0aW5nIGFlczEyOGdjbSB0byBwb3B1bGF0ZSB0aGUgaGVhZGVyIHZhbHVlcy4gTW9kaWZpZXMgdGhlXG4gKiBoZWFkZXIgdmFsdWVzIGluIHBsYWNlIGFuZCByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBoZWFkZXIuICovXG5mdW5jdGlvbiByZWFkSGVhZGVyKGJ1ZmZlciwgaGVhZGVyKSB7XG4gIHZhciBpZHN6ID0gYnVmZmVyLnJlYWRVSW50QkUoMjAsIDEpO1xuICBoZWFkZXIuc2FsdCA9IGJ1ZmZlci5zbGljZSgwLCBLRVlfTEVOR1RIKTtcbiAgaGVhZGVyLnJzID0gYnVmZmVyLnJlYWRVSW50QkUoS0VZX0xFTkdUSCwgNCk7XG4gIGhlYWRlci5rZXlpZCA9IGJ1ZmZlci5zbGljZSgyMSwgMjEgKyBpZHN6KTtcbiAgcmV0dXJuIDIxICsgaWRzejtcbn1cblxuZnVuY3Rpb24gdW5wYWRMZWdhY3koZGF0YSwgdmVyc2lvbikge1xuICB2YXIgcGFkU2l6ZSA9IFBBRF9TSVpFW3ZlcnNpb25dO1xuICB2YXIgcGFkID0gZGF0YS5yZWFkVUludEJFKDAsIHBhZFNpemUpO1xuICBpZiAocGFkICsgcGFkU2l6ZSA+IGRhdGEubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGV4Y2VlZHMgYmxvY2sgc2l6ZScpO1xuICB9XG4gIGtleWxvZygncGFkZGluZycsIGRhdGEuc2xpY2UoMCwgcGFkU2l6ZSArIHBhZCkpO1xuICB2YXIgcGFkQ2hlY2sgPSBCdWZmZXIuYWxsb2MocGFkKTtcbiAgcGFkQ2hlY2suZmlsbCgwKTtcbiAgaWYgKHBhZENoZWNrLmNvbXBhcmUoZGF0YS5zbGljZShwYWRTaXplLCBwYWRTaXplICsgcGFkKSkgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGFkZGluZycpO1xuICB9XG4gIHJldHVybiBkYXRhLnNsaWNlKHBhZFNpemUgKyBwYWQpO1xufVxuXG5mdW5jdGlvbiB1bnBhZChkYXRhLCBsYXN0KSB7XG4gIHZhciBpID0gZGF0YS5sZW5ndGggLSAxO1xuICB3aGlsZShpID49IDApIHtcbiAgICBpZiAoZGF0YVtpXSkge1xuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgaWYgKGRhdGFbaV0gIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgcmVjb3JkIG5lZWRzIHRvIHN0YXJ0IHBhZGRpbmcgd2l0aCBhIDInKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGFbaV0gIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgcmVjb3JkIG5lZWRzIHRvIHN0YXJ0IHBhZGRpbmcgd2l0aCBhIDInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgaSk7XG4gICAgfVxuICAgIC0taTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2FsbCB6ZXJvIHBsYWludGV4dCcpO1xufVxuXG5mdW5jdGlvbiBkZWNyeXB0UmVjb3JkKGtleSwgY291bnRlciwgYnVmZmVyLCBoZWFkZXIsIGxhc3QpIHtcbiAga2V5bG9nKCdkZWNyeXB0JywgYnVmZmVyKTtcbiAgdmFyIG5vbmNlID0gZ2VuZXJhdGVOb25jZShrZXkubm9uY2UsIGNvdW50ZXIpO1xuICB2YXIgZ2NtID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoQUVTX0dDTSwga2V5LmtleSwgbm9uY2UpO1xuICBnY20uc2V0QXV0aFRhZyhidWZmZXIuc2xpY2UoYnVmZmVyLmxlbmd0aCAtIFRBR19MRU5HVEgpKTtcbiAgdmFyIGRhdGEgPSBnY20udXBkYXRlKGJ1ZmZlci5zbGljZSgwLCBidWZmZXIubGVuZ3RoIC0gVEFHX0xFTkdUSCkpO1xuICBkYXRhID0gQnVmZmVyLmNvbmNhdChbZGF0YSwgZ2NtLmZpbmFsKCldKTtcbiAga2V5bG9nKCdkZWNyeXB0ZWQnLCBkYXRhKTtcbiAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgIHJldHVybiB1bnBhZExlZ2FjeShkYXRhLCBoZWFkZXIudmVyc2lvbik7XG4gIH1cbiAgcmV0dXJuIHVucGFkKGRhdGEsIGxhc3QpO1xufVxuXG4vKipcbiAqIERlY3J5cHQgc29tZSBieXRlcy4gIFRoaXMgdXNlcyB0aGUgcGFyYW1ldGVycyB0byBkZXRlcm1pbmUgdGhlIGtleSBhbmQgYmxvY2tcbiAqIHNpemUsIHdoaWNoIGFyZSBkZXNjcmliZWQgaW4gdGhlIGRyYWZ0LiAgQmluYXJ5IHZhbHVlcyBhcmUgYmFzZTY0dXJsIGVuY29kZWQuXG4gKlxuICogfHBhcmFtcy52ZXJzaW9ufCBjb250YWlucyB0aGUgdmVyc2lvbiBvZiBlbmNvZGluZyB0byB1c2U6IGFlczEyOGdjbSBpcyB0aGUgbGF0ZXN0LFxuICogYnV0IGFlc2djbSBpcyBhbHNvIGFjY2VwdGVkICh0aG91Z2ggdGhlIGxhdHRlciBtaWdodFxuICogZGlzYXBwZWFyIGluIGEgZnV0dXJlIHJlbGVhc2UpLiAgSWYgb21pdHRlZCwgYXNzdW1lIGFlczEyOGdjbS5cbiAqXG4gKiBJZiB8cGFyYW1zLmtleXwgaXMgc3BlY2lmaWVkLCB0aGF0IHZhbHVlIGlzIHVzZWQgYXMgdGhlIGtleS5cbiAqXG4gKiBJZiB0aGUgdmVyc2lvbiBpcyBhZXMxMjhnY20sIHRoZSBrZXlpZCBpcyBleHRyYWN0ZWQgZnJvbSB0aGUgaGVhZGVyIGFuZCB1c2VkXG4gKiBhcyB0aGUgRUNESCBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIuICBGb3IgdmVyc2lvbiBhZXNnY20gLFxuICogfHBhcmFtcy5kaHwgbmVlZHMgdG8gYmUgcHJvdmlkZWQgd2l0aCB0aGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLlxuICpcbiAqIFRoZSB8cGFyYW1zLnByaXZhdGVLZXl8IGluY2x1ZGVzIHRoZSBwcml2YXRlIGtleSBvZiB0aGUgcmVjZWl2ZXIuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHQoYnVmZmVyLCBwYXJhbXMsIGtleUxvb2t1cENhbGxiYWNrKSB7XG4gIHZhciBoZWFkZXIgPSBwYXJzZVBhcmFtcyhwYXJhbXMpO1xuICBpZiAoaGVhZGVyLnZlcnNpb24gPT09ICdhZXMxMjhnY20nKSB7XG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IHJlYWRIZWFkZXIoYnVmZmVyLCBoZWFkZXIpO1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShoZWFkZXJMZW5ndGgpO1xuICB9XG4gIHZhciBrZXkgPSBkZXJpdmVLZXlBbmROb25jZShoZWFkZXIsIE1PREVfREVDUllQVCwga2V5TG9va3VwQ2FsbGJhY2spO1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKDApO1xuXG4gIHZhciBjaHVua1NpemUgPSBoZWFkZXIucnM7XG4gIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICBjaHVua1NpemUgKz0gVEFHX0xFTkdUSDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBzdGFydCA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgIHZhciBlbmQgPSBzdGFydCArIGNodW5rU2l6ZTtcbiAgICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nICYmIGVuZCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnVuY2F0ZWQgcGF5bG9hZCcpO1xuICAgIH1cbiAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGJ1ZmZlci5sZW5ndGgpO1xuICAgIGlmIChlbmQgLSBzdGFydCA8PSBUQUdfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvY2s6IHRvbyBzbWFsbCBhdCAnICsgaSk7XG4gICAgfVxuICAgIHZhciBibG9jayA9IGRlY3J5cHRSZWNvcmQoa2V5LCBpLCBidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIsIGVuZCA+PSBidWZmZXIubGVuZ3RoKTtcbiAgICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KFtyZXN1bHQsIGJsb2NrXSk7XG4gICAgc3RhcnQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jcnlwdFJlY29yZChrZXksIGNvdW50ZXIsIGJ1ZmZlciwgcGFkLCBoZWFkZXIsIGxhc3QpIHtcbiAga2V5bG9nKCdlbmNyeXB0JywgYnVmZmVyKTtcbiAgcGFkID0gcGFkIHx8IDA7XG4gIHZhciBub25jZSA9IGdlbmVyYXRlTm9uY2Uoa2V5Lm5vbmNlLCBjb3VudGVyKTtcbiAgdmFyIGdjbSA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihBRVNfR0NNLCBrZXkua2V5LCBub25jZSk7XG5cbiAgdmFyIGNpcGhlcnRleHQgPSBbXTtcbiAgdmFyIHBhZFNpemUgPSBQQURfU0laRVtoZWFkZXIudmVyc2lvbl07XG4gIHZhciBwYWRkaW5nID0gQnVmZmVyLmFsbG9jKHBhZCArIHBhZFNpemUpO1xuICBwYWRkaW5nLmZpbGwoMCk7XG5cbiAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgIHBhZGRpbmcud3JpdGVVSW50QkUocGFkLCAwLCBwYWRTaXplKTtcbiAgICBrZXlsb2coJ3BhZGRpbmcnLCBwYWRkaW5nKTtcbiAgICBjaXBoZXJ0ZXh0LnB1c2goZ2NtLnVwZGF0ZShwYWRkaW5nKSk7XG4gICAgY2lwaGVydGV4dC5wdXNoKGdjbS51cGRhdGUoYnVmZmVyKSk7XG5cbiAgICBpZiAoIWxhc3QgJiYgcGFkZGluZy5sZW5ndGggKyBidWZmZXIubGVuZ3RoIDwgaGVhZGVyLnJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYWQgdG8gcmVjb3JkIHNpemUnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2lwaGVydGV4dC5wdXNoKGdjbS51cGRhdGUoYnVmZmVyKSk7XG4gICAgcGFkZGluZy53cml0ZVVJbnRCRShsYXN0ID8gMiA6IDEsIDAsIDEpO1xuICAgIGtleWxvZygncGFkZGluZycsIHBhZGRpbmcpO1xuICAgIGNpcGhlcnRleHQucHVzaChnY20udXBkYXRlKHBhZGRpbmcpKTtcbiAgfVxuXG4gIGdjbS5maW5hbCgpO1xuICB2YXIgdGFnID0gZ2NtLmdldEF1dGhUYWcoKTtcbiAgaWYgKHRhZy5sZW5ndGggIT09IFRBR19MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFnIGdlbmVyYXRlZCcpO1xuICB9XG4gIGNpcGhlcnRleHQucHVzaCh0YWcpO1xuICByZXR1cm4ga2V5bG9nKCdlbmNyeXB0ZWQnLCBCdWZmZXIuY29uY2F0KGNpcGhlcnRleHQpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVIZWFkZXIoaGVhZGVyKSB7XG4gIHZhciBpbnRzID0gQnVmZmVyLmFsbG9jKDUpO1xuICB2YXIga2V5aWQgPSBCdWZmZXIuZnJvbShoZWFkZXIua2V5aWQgfHwgW10pO1xuICBpZiAoa2V5aWQubGVuZ3RoID4gMjU1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdrZXlpZCBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICBpbnRzLndyaXRlVUludEJFKGhlYWRlci5ycywgMCwgNCk7XG4gIGludHMud3JpdGVVSW50QkUoa2V5aWQubGVuZ3RoLCA0LCAxKTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2hlYWRlci5zYWx0LCBpbnRzLCBrZXlpZF0pO1xufVxuXG4vKipcbiAqIEVuY3J5cHQgc29tZSBieXRlcy4gIFRoaXMgdXNlcyB0aGUgcGFyYW1ldGVycyB0byBkZXRlcm1pbmUgdGhlIGtleSBhbmQgYmxvY2tcbiAqIHNpemUsIHdoaWNoIGFyZSBkZXNjcmliZWQgaW4gdGhlIGRyYWZ0LlxuICpcbiAqIHxwYXJhbXMudmVyc2lvbnwgY29udGFpbnMgdGhlIHZlcnNpb24gb2YgZW5jb2RpbmcgdG8gdXNlOiBhZXMxMjhnY20gaXMgdGhlIGxhdGVzdCxcbiAqIGJ1dCBhZXNnY20gaXMgYWxzbyBhY2NlcHRlZCAodGhvdWdoIHRoZSBsYXR0ZXIgdHdvIG1pZ2h0XG4gKiBkaXNhcHBlYXIgaW4gYSBmdXR1cmUgcmVsZWFzZSkuICBJZiBvbWl0dGVkLCBhc3N1bWUgYWVzMTI4Z2NtLlxuICpcbiAqIElmIHxwYXJhbXMua2V5fCBpcyBzcGVjaWZpZWQsIHRoYXQgdmFsdWUgaXMgdXNlZCBhcyB0aGUga2V5LlxuICpcbiAqIEZvciBEaWZmaWUtSGVsbG1hbiAoV2ViUHVzaCksIHxwYXJhbXMuZGh8IGluY2x1ZGVzIHRoZSBwdWJsaWMga2V5IG9mIHRoZVxuICogcmVjZWl2ZXIuICB8cGFyYW1zLnByaXZhdGVLZXl8IGlzIHVzZWQgdG8gZXN0YWJsaXNoIGEgc2hhcmVkIHNlY3JldC4gIEtleVxuICogcGFpcnMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgfGNyeXB0by5jcmVhdGVFQ0RIKCl8LlxuICovXG5mdW5jdGlvbiBlbmNyeXB0KGJ1ZmZlciwgcGFyYW1zLCBrZXlMb29rdXBDYWxsYmFjaykgeyAgXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZmZlciBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyk7XG4gIH1cbiAgdmFyIGhlYWRlciA9IHBhcnNlUGFyYW1zKHBhcmFtcyk7XG4gIGlmICghaGVhZGVyLnNhbHQpIHtcbiAgICBoZWFkZXIuc2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcyhLRVlfTEVOR1RIKTtcbiAgfVxuXG4gIHZhciByZXN1bHQ7XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICAvLyBTYXZlIHRoZSBESCBwdWJsaWMga2V5IGluIHRoZSBoZWFkZXIgdW5sZXNzIGtleWlkIGlzIHNldC5cbiAgICBpZiAoaGVhZGVyLnByaXZhdGVLZXkgJiYgIWhlYWRlci5rZXlpZCkge1xuICAgICAgaGVhZGVyLmtleWlkID0gaGVhZGVyLnByaXZhdGVLZXkuZ2V0UHVibGljS2V5KCk7XG4gICAgfVxuICAgIHJlc3VsdCA9IHdyaXRlSGVhZGVyKGhlYWRlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gaGVhZGVyIG9uIG90aGVyIHZlcnNpb25zXG4gICAgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKDApO1xuICB9XG5cbiAgdmFyIGtleSA9IGRlcml2ZUtleUFuZE5vbmNlKGhlYWRlciwgTU9ERV9FTkNSWVBULCBrZXlMb29rdXBDYWxsYmFjayk7XG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBwYWRTaXplID0gUEFEX1NJWkVbaGVhZGVyLnZlcnNpb25dO1xuICB2YXIgb3ZlcmhlYWQgPSBwYWRTaXplO1xuICBpZiAoaGVhZGVyLnZlcnNpb24gPT09ICdhZXMxMjhnY20nKSB7XG4gICAgb3ZlcmhlYWQgKz0gVEFHX0xFTkdUSDtcbiAgfVxuICB2YXIgcGFkID0gaXNOYU4ocGFyc2VJbnQocGFyYW1zLnBhZCwgMTApKSA/IDAgOiBwYXJzZUludChwYXJhbXMucGFkLCAxMCk7XG5cbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgbGFzdCA9IGZhbHNlO1xuICB3aGlsZSAoIWxhc3QpIHtcbiAgICAvLyBQYWQgc28gdGhhdCBhdCBsZWFzdCBvbmUgZGF0YSBieXRlIGlzIGluIGEgYmxvY2suXG4gICAgdmFyIHJlY29yZFBhZCA9IE1hdGgubWluKGhlYWRlci5ycyAtIG92ZXJoZWFkIC0gMSwgcGFkKTtcbiAgICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgICByZWNvcmRQYWQgPSBNYXRoLm1pbigoMSA8PCAocGFkU2l6ZSAqIDgpKSAtIDEsIHJlY29yZFBhZCk7XG4gICAgfVxuICAgIGlmIChwYWQgPiAwICYmIHJlY29yZFBhZCA9PT0gMCkge1xuICAgICAgKytyZWNvcmRQYWQ7IC8vIERlYWwgd2l0aCBwZXJ2ZXJzZSBjYXNlIG9mIHJzPW92ZXJoZWFkKzEgd2l0aCBwYWRkaW5nLlxuICAgIH1cbiAgICBwYWQgLT0gcmVjb3JkUGFkO1xuXG4gICAgdmFyIGVuZCA9IHN0YXJ0ICsgaGVhZGVyLnJzIC0gb3ZlcmhlYWQgLSByZWNvcmRQYWQ7XG4gICAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgICAgLy8gVGhlID4gaGVyZSBlbnN1cmVzIHRoYXQgd2Ugd3JpdGUgb3V0IGEgcGFkZGluZy1vbmx5IGJsb2NrIGF0IHRoZSBlbmRcbiAgICAgIC8vIG9mIGEgYnVmZmVyLlxuICAgICAgbGFzdCA9IGVuZCA+IGJ1ZmZlci5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQgPj0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgbGFzdCA9IGxhc3QgJiYgcGFkIDw9IDA7XG4gICAgdmFyIGJsb2NrID0gZW5jcnlwdFJlY29yZChrZXksIGNvdW50ZXIsIGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZFBhZCwgaGVhZGVyLCBsYXN0KTtcbiAgICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KFtyZXN1bHQsIGJsb2NrXSk7XG5cbiAgICBzdGFydCA9IGVuZDtcbiAgICArK2NvdW50ZXI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mKG9iamVjdCkgPT09ICdmdW5jdGlvbic7XG4gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVjcnlwdDogZGVjcnlwdCxcbiAgZW5jcnlwdDogZW5jcnlwdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http_ece/ece.js\n");

/***/ })

};
;